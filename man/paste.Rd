% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paste.R
\name{paste}
\alias{paste}
\alias{paste0}
\alias{\%+\%}
\alias{strcat}
\title{Concatenate Strings}
\usage{
paste(..., sep = " ", collapse = NULL, recycle0 = FALSE)

paste0(..., sep = "", collapse = NULL, recycle0 = FALSE)

e1 \%+\% e2

strcat(x, collapse = "", na.rm = FALSE)
}
\arguments{
\item{sep}{a single string; separates terms}

\item{collapse}{a single string or \code{NULL}; an optional
separator if tokens are to be merged into a single string}

\item{recycle0}{a single logical value; if \code{FALSE}, then empty
vectors provided via \code{...} are silently ignored}

\item{e1, e2, ...}{character vectors (or objects coercible to character vectors)
whose corresponding elements are to be concatenated
whose consecutive elements are to be concatenated}

\item{na.rm}{a single logical value; if \code{TRUE}, missing values
are silently ignored}
}
\value{
Return a character vector (in UTF-8).
}
\description{
Concatenate (join) the corresponding and/or consecutive elements of
given vectors, after converting them to strings.

Instead of \code{paste} and \code{paste0}, we recommend using
\code{`\%+\%`}, \code{sprintf}, and \code{strcat}.
}
\details{
Replacement for base \code{\link[base]{paste}}
implemented with \code{\link[stringi]{stri_join}}.

\code{paste} can be thought of as a string counterpart
of both the \code{`+`} operator (actually, some languages do have a binary
operator for string concatenation, e.g., \code{`.`} in PHP, \code{`+`}
in Python; R should have it too, but does not)
and the \code{\link[base]{sum}} function.
Therefore, we would expect it to behave similarly with regards
to the propagation of missing values and the preservation of object
attributes, but it does not.

Inconsistencies in base R and the way we have addressed them here:

\itemize{
\item missing values treated as \code{"NA"} strings (it is a well-documented
    feature though) \bold{[fixed here]};
\item partial recycling with no warning "longer object length is not
    a multiple of shorter object length" \bold{[fixed here]};
\item empty vectors are treated as vectors of empty strings
    \bold{[fixed here]};
\item input objects' attributes are not preserved
    \bold{[not fixed]};
\item \code{paste0} multiplies entities without necessity;
    \code{sep=""} should be the default in \code{paste} \bold{[not fixed]};
\item \code{paste0} treats named argument \code{sep="..."} as one
    more vector to concatenate
    \bold{[fixed by introducing \code{sep} argument]}.
}

It should also be noted that \code{paste} with \code{collapse=NULL} is a
special case of \code{sprintf} (which is featured in many programming
languages; R's version is of course vectorised).
For instance, \code{paste(x, y, sep=",")}
is equivalent to \code{sprintf("\%s,\%s", x, y)}.

Taking into account the above, \code{paste} and \code{paste0} seem
redundant. Here are our recommendations:

\itemize{
\item the most frequent use case - concatenating corresponding
    strings from two character vectors with no separator - is covered
    by a new operator \code{`\%+\%`} which propagates NAs correctly
    and handles object attributes the same way as the built-in arithmetic
    operators;
\item for fancy elementwise (like 'Map') concatenation,
    use our version of \code{\link{sprintf}};
\item for the 'flattening' of consecutive strings in a character vector
    (like 'Reduce'), use the new function \code{strcat}.
}
}
\examples{
# behaviour of `+` vs. base::paste vs. stringx::paste
x <- structure(c(x=1, y=NA, z=100, w=1000), F="*")
y1 <- structure(c(a=1, b=2, c=3), G="#", F="@")
y2 <- structure(c(a=1, b=2, c=3, d=4), G="#", F="@")
y3 <- structure(1:4, G="#", F="@", dim=c(2, 2), dimnames=list(NULL, c("a", "b")))
x + y1
x + y2
x + y3
y2 + x
base::paste(x, y1)
base::paste(x, y2)
base::paste(x, y3)
stringx::paste(x, y1)
stringx::paste(x, y2)
stringx::paste(x, y3)
base::paste(x, character(0), y2, sep=",")
stringx::paste(x, character(0), y2, sep=",")
x \%+\% y1
x \%+\% y2
x \%+\% y3
y2 \%+\% x
x \%+\% character(0)
strcat(x, collapse=",")
strcat(x, collapse=",", na.rm=TRUE)

}
